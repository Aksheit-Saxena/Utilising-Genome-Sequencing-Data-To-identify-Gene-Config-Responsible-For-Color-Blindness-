# -*- coding: utf-8 -*-
"""Assignment4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hXXL3ZJsXwptHz7_qP8iOY3lsP_wCW-6
"""
import pandas as pd
import torch
import numpy as np
import time
import math
from functools import reduce
import operator as op

# reading last column data from file
def last_col_(path):
    last_col = np.loadtxt(path, dtype=str)
    last_col = ''.join(last_col)
    return last_col

# reading map data from file
def mapping_(path):
    mapping = np.loadtxt(path, dtype=int)
    return mapping

# reading reference sequence from file
def refer_(path):
    refer = np.loadtxt(path, dtype=str)
    refer = refer[1:]
    refer = ''.join(refer)
    return refer

# reading reads from file
def reads_(path):
    reads = np.loadtxt(path, dtype=str)
    return reads

# function for rank query based on delta value
def calcrank(ch, i):
    rank = 0
    if i == 0:
        return 0
    if ch == 'A':
        while (i - 1) % delta != 0:
            i -= 1
            if A[i] == 1:
                rank += 1
        rank += del_A[(i-1) // delta]
        return rank
    elif ch == 'C':
        while (i - 1) % delta != 0:
            i -= 1
            if C[i] == 1:
                rank += 1
        rank += del_C[(i-1) // delta]
        return rank
    elif ch == 'G':
        while (i - 1) % delta != 0:
            i -= 1
            if G[i] == 1:
                rank += 1
        rank += del_G[(i-1) // delta]
        return rank
    elif ch == 'T' :
        while (i - 1) % delta != 0:
            i -= 1
            if T[i] == 1:
                rank += 1
        rank += del_T[(i-1) // delta]
        return rank

# band calculation
def band_(idx, rank):
    if idx == 'A':
        return 0 + rank
    elif idx == 'C':
        return a + rank
    elif idx == 'G':
        return a + c + rank
    elif idx == 'T':
        return a + c + g + rank
    else:
        print("No match for token!")

# getting first column data from last column data
def get_first_column_data(last_column_data):
    char_counts = {}
    char_counts["A"] = last_column_data.count("A")
    char_counts["C"] = last_column_data.count("C")
    char_counts["G"] = last_column_data.count("G")
    char_counts["T"] = last_column_data.count("T")
    char_counts["$"] = last_column_data.count("$")
    print(char_counts)
    return char_counts

# getting counts for each character in the last column data
def count_(lst_col):
    last_col_len = len(lst_col)
    A = np.zeros(last_col_len, dtype=int)
    C = np.zeros(last_col_len, dtype=int)
    G = np.zeros(last_col_len, dtype=int)
    T = np.zeros(last_col_len, dtype=int)
    del_A= []
    del_C = []
    del_G = []
    del_T = []



    a_c = 0
    c_c = 0
    g_c = 0
    t_c = 0
    for i in range(last_col_len ):
        char = lst_col[i]
        if char == "A":
            A[i] = 1
            a_c+= 1
        elif char == "C":
            C[i] = 1
            c_c += 1
        elif char == "G":
            G[i] = 1
            g_c+= 1
        elif char == "T":
            T[i] = 1
            t_c+= 1
        else:
            print('Found $ at position: ' + str(i))

        if i % delta == 0:
            del_G.append(g)
            del_A.append(a)
            del_T.append(t)
            del_C.append(c)

    return A, C, G, T, del_A, del_C, del_G, del_T

def match_idx_(txt):
    last_char = txt[-1]
    if last_char == 'A':
        band_0 = 0
        band_1 = a - 1
    elif last_char == 'C':
        band_0 = a
        band_1 = a + c - 1
    elif last_char == 'G':
        band_0 = a + c
        band_1 = a + c + g - 1
    elif last_char == 'T':
        band_0 = a + c + g
        band_1 = a + c + g + t - 1
    for i in range(2, len(txt)+1):
        char = txt[-i]
        rank_0 = calcrank(char, band_0)
        rank_1 = calcrank(char, band_1)
        if rank_0 == rank_1:
            return None, None
        band_0 = band_(char, rank_0)
        band_1 = band_(char, rank_1)
    return band_0, band_1

def exon_match_counts(start, end, read_length):
    ref_seq_index_matches = []
    for i in range(end - start):
        ref_seq_index_matches.append(int(mapping_v[start+i]))
    red_exon_numbers = []
    green_exon_numbers = []
    for ref_seq_index in ref_seq_index_matches:
        is_red, red_exon_number = is_red_(ref_seq_index, read_length)
        is_green, green_exon_number = is_green_(ref_seq_index, read_length)
        if is_red:
            red_exon_numbers.append(red_exon_number)
        if is_green:
            green_exon_numbers.append(green_exon_number)

    if len(red_exon_numbers) > 0 and len(green_exon_numbers) > 0:
        for exon_number in red_exon_numbers:
            red_exon[exon_number] += 0.5
        for exon_number in green_exon_numbers:
            green_exon[exon_number] += 0.5
    elif len(red_exon_numbers) > 0:
        for exon_number in red_exon_numbers:
            red_exon[exon_number] += 1
    elif len(green_exon_numbers) > 0:
        for exon_number in green_exon_numbers:
            green_exon[exon_number] += 0.5
    else:
        pass

def is_green_(idx, length):
    if idx >= green[0][0] and idx <= green[0][1]:
        return True, 0
    elif idx >= green[1][0] and idx <= green[1][1]:
        return True, 1
    elif idx >= green[2][0] and idx <= green[2][1]:
        return True, 2
    elif idx >= green[3][0] and idx <= green[3][1]:
        return True, 3
    elif idx >= green[4][0] and idx <= green[4][1]:
        return True, 4
    elif idx >= green[5][0] and idx <= green[5][1]:
        return True, 5
    else:
        return False, -1

def is_red_(index, length):
    if index >= red[0][0] and index <= red[0][1]:
        return True, 0
    elif index >= red[1][0] and index <= red[1][1]:
        return True, 1
    elif index >= red[2][0] and index <= red[2][1]:
        return True, 2
    elif index >= red[3][0] and index <= red[3][1]:
        return True, 3
    elif index >= red[4][0] and index <= red[4][1]:
        return True, 4
    elif index >= red[5][0] and index <= red[5][1]:
        return True, 5
    else:
        return False, -1

def match_ref_idx(start_index, end_index):
    ref_seq_index_matches = []
    for i in range(end_index - start_index):
        ref_seq_index_matches.append(int(mapping_v[start_index+i]))
    return ref_seq_index_matches

def mismatch_count_(index, read):
    mismatch_count = 0
    if len_ref_seq <= index + len(read):
        return -1
    for i in range(len(read)):
        if(refer_v[index+i] != read[i]):
            mismatch_count += 1
    return mismatch_count

def permut(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer//denom

if __name__ == '__main__':

    delta = 1
    reads_v = reads_('./data/reads')
    mapping_v = mapping_('./data/chrX_map.txt')
    refer_v = refer_('./data/chrX.fa')
    last_col_v = last_col_('./data/chrX_last_col.txt')


    red = np.array([[149249757, 149249868],
                                [149256127, 149256423],
                                [149258412, 149258580],
                                [149260048, 149260213],
                                [149261768, 149262007],
                                [149264290, 149264400]])

    green = np.array([[149288166, 149288277],
                                [149293258, 149293554],
                                [149295542, 149295710],
                                [149297178, 149297343],
                                [149298898, 149299137],
                                [149301420, 149301530]])

    print("Length of the map data: " + str(len(mapping_v)))

    test = 'GAGGACAGCACCCAGTCCAGCATCTTCACCTACACCAACAGCAACTCCACCAGAGGTGAGCCAGCAGGCCCGTGGAGGCTGGGTGGCTGCACTGGGGGCCA'

    # first column data
    cvc = get_first_column_data(last_col_v)
    a = cvc['A']
    c = cvc['C']
    g = cvc['G']
    t = cvc['T']

    A, C, G, T, del_A, del_C, del_G, del_T = count_(last_col_v)

    red_exon = [0, 0, 0, 0, 0, 0]
    green_exon = [0, 0, 0, 0, 0, 0]

    total_reads = reads_v[200000:300000]

    # replacing N with A in all reads
    Total_reads_new = []
    for read in total_reads:
        if 'N' in read:
            new_read = read.replace('N', 'A')
            Total_reads_new.append(new_read)
        else:
            Total_reads_new.append(read)

    # finding reverse compliments of all reads
    total_reads_compliment = []
    for read in Total_reads_new:
        reverse_read = read[::-1]
        temp_M = reverse_read.replace('G', 'M')
        temp_G = temp_M.replace('C', 'G')
        temp_C = temp_G.replace('M', 'C')
        temp_N = temp_C.replace('A', 'N')
        temp_T = temp_N.replace('T', 'A')
        temp_A = temp_T.replace('N', 'T')
        total_reads_compliment.append(temp_A)

    band_first_match_index, band_last_match_index = match_idx_(test)
    print("Band first match index: " + str(band_first_match_index))
    print("Band last match index: " + str(band_last_match_index))
    print('Map value for test string: ' + str(mapping_v[band_first_match_index]))


    ### exact matching code
    for read in Total_reads_new:
        band_first_match_index, band_last_match_index = match_idx_(read)
        if band_first_match_index is not None and band_last_match_index is not None:
            exon_match_counts(band_first_match_index, band_last_match_index, len(read))

    print("Counts for exact match of red gene")
    print(red_exon)
    print("Counts for exact match of green gene")
    print(green_exon)


    len_ref_seq = len(refer_v)

    for read in Total_reads_new:
        read_length = len(read)
        first_part = read[:read_length//3]
        second_part = read[read_length//3: 2*read_length//3]
        third_part = read[2*read_length//3:]
        first_part_band_match_start_index, first_part_band_match_end_index = match_idx_(first_part)
        second_part_band_match_start_index, second_part_band_match_end_index = match_idx_(second_part)
        third_part_band_match_start_index, third_part_band_match_end_index = match_idx_(third_part)

        first_ref_matches = []
        second_ref_matches = []
        third_ref_matches = []

        if first_part_band_match_start_index is not None and first_part_band_match_end_index is not None:
            first_ref_matches = match_ref_idx(first_part_band_match_start_index, first_part_band_match_end_index)

        if second_part_band_match_start_index is not None and second_part_band_match_end_index is not None:
            second_ref_matches = match_ref_idx(second_part_band_match_start_index, second_part_band_match_end_index)

        if third_part_band_match_start_index is not None and third_part_band_match_end_index is not None:
            third_ref_matches = match_ref_idx(third_part_band_match_start_index, third_part_band_match_end_index)

        len_first_part = len(first_part)
        len_second_part = len(second_part)
        len_third_part = len(third_part)
        third_ref_matches = [val -len_first_part - len_second_part for val in third_ref_matches]

        common_matches = set(first_ref_matches) & set(second_ref_matches) & set(third_ref_matches)
        first_remaining_matches = set(first_ref_matches).difference(common_matches)
        second_remaining_matches = set(second_ref_matches).difference(common_matches)
        third_remaining_matches = set(third_ref_matches).difference(common_matches)
        all_remaining_matches = list(first_remaining_matches.union(second_remaining_matches.union(third_remaining_matches)))

        if(len(all_remaining_matches) > 0):
            red_exon_numbers = []
            green_exon_numbers = []
            for i in range(len(all_remaining_matches)):
                mismatch_count = mismatch_count_(all_remaining_matches[i], read)
                if mismatch_count > 0 and mismatch_count < 3:
                    is_red_match, red_exon_number = is_red_(all_remaining_matches[i], read_length)
                    is_green_match, green_exon_number = is_green_(all_remaining_matches[i], read_length)
                    if is_red_match:
                        red_exon_numbers.append(red_exon_number)
                    if is_green_match:
                        green_exon_numbers.append(green_exon_number)

            if len(red_exon_numbers) > 0 and len(green_exon_numbers) > 0:
                for exon_number in red_exon_numbers:
                    red_exon[exon_number] += 0.5
                for exon_number in green_exon_numbers:
                    green_exon[exon_number] += 0.5
            elif len(red_exon_numbers) > 0:
                for exon_number in red_exon_numbers:
                    red_exon[exon_number] += 1
            elif len(green_exon_numbers) > 0:
                for exon_number in green_exon_numbers:
                    green_exon[exon_number] += 0.5
            else:
                pass

    print("Red exon count considering up to two mismatches :: ")
    print(red_exon)
    print("Green exon count considering up to two mismatches :: ")
    print(green_exon)

    end_time = time.time()
    time_taken = end_time - start_time
    print("Time taken :: " + str(time_taken))

    red_exon_count = [int(count) for count in red_exon]
    green_exon_count = [int(count) for count in green_exon]
    total_count = []
    assert len(red_exon_count) == len(green_exon_count)
    for i in range(len(red_exon_count)):
        count = red_exon_count[i] + green_exon_count[i]
        total_count.append(count)

    config_1_red = [0.33, 0.33, 0.33, 0.33]
    config_1_green = [0.66, 0.66, 0.66, 0.66]

    config_2_red = [0.5, 0.5, 0, 0]
    config_2_green = [0.5, 0.5, 1.0, 1.0]

    config_3_red = [0.25, 0.25, 0.5, 0.5]
    config_3_green = [0.75, 0.75, 0.5, 0.5]

    config_4_red = [0.25, 0.25, 0.25, 0.5]
    config_4_green = [0.75, 0.75, 0.75, 0.5]

    probabilities = []
    prob_1 = 0
    for i in range(len(config_1_red)):
        prob_1 += red_exon_count[i+1]*math.log(config_1_red[i]) + green_exon_count[i+1]*math.log(config_1_green[i]) + math.log(permut(total_count[i+1], red_exon_count[i+1]))

    prob_3 = 0
    for i in range(len(config_3_red)):
        prob_3 += red_exon_count[i+1]*math.log(config_3_red[i]) + green_exon_count[i+1]*math.log(config_3_green[i]) + math.log(permut(total_count[i+1], red_exon_count[i+1]))

    prob_4 = 0
    for i in range(len(config_4_red)):
        prob_4 += red_exon_count[i+1]*math.log(config_4_red[i]) + green_exon_count[i+1]*math.log(config_4_green[i]) + math.log(permut(total_count[i+1], red_exon_count[i+1]))

    print('Log probability for config-1 :: ' + str(prob_1))
    print('Log probability for config-3 :: ' + str(prob_3))
    print('Log probability for config-4 :: ' + str(prob_4))

    print('')
    print('Probability for config-1 :: ' + str(math.exp(prob_1)))
    print('Probability for config-3 :: ' + str(math.exp(prob_3)))
    print('Probability for config-4 :: ' + str(math.exp(prob_4)))

